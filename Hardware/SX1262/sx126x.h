/*
  ______                              _
 / _____)             _              | |
( (____  _____ ____ _| |_ _____  ____| |__
 \____ \| ___ |    (_   _) ___ |/ ___)  _ \
 _____) ) ____| | | || |_| ____( (___| | | |
(______/|_____)_|_|_| \__)_____)\____)_| |_|
	(C)2017 Semtech

Description: Generic SX126x driver implementation

License: Revised BSD License, see LICENSE.TXT file include in the project

Authors: Miguel Luis, Gregory Cristian
*/
#ifndef __SX126x_H__
#define __SX126x_H__

#include "radio.h"
#include <stdint.h>



/*!
 * \brief Enables/disables driver debug features
 */
#define SX126x_DEBUG                                0



/*!
 * \brief Hardware IO IRQ callback function definition
 */
//class SX126x;
//typedef void (SX126x::*DioIrqHandler)(void);

/*!
 * \brief IRQ triggers callback function definition
 */
//class SX126xHal;
//typedef void (SX126xHal::*Trigger)(void);

//#warning "modified"

/*!
 * \brief Instantiates a SX126x object and provides API functions to communicates with the radio
 * \param [in]  callbacks      Pointer to the callbacks structure defining
 *                             all callbacks function pointers
 */
void SX126xInit(RadioCallbacks_t * callbacks);
// 	{
// 		//this->dioIrq      = &SX126x::OnDioIrq;
// 		this->PacketType = PACKET_TYPE_NONE;
// 		this->PollingMode = false;
// 		this->IrqState = false;
// 	}


//#warning "Js: publiced"

/*!
 * \brief Sets a function to be triggered on radio interrupt
 *
 * \param [in]  irqHandler    A pointer to a function to be run on interrupt
 *                            from the radio
 */
//virtual void IoIrqInit(DioIrqHandler irqHandler) ;

/*!
 * \brief DIOs interrupt callback
 *
 * \remark Called to handle all 3 DIOs pins
 */
void SX126xOnDioIrq(void);

/*!
* \brief Hardware DIO IRQ functions
*/
//	DioIrqHandler dioIrq;

/*!
 * \brief Initializes the radio driver
 */
void SX126xSX126xInit(RadioCallbacks_t* callbacks);

/*!
 * \brief Gets the current Operation Mode of the Radip
 *
 * \retval      RadioOperatingModes_t last operating mode
 */
RadioOperatingModes_t SX126xGetOperatingMode(void);

/*!
 * \brief Wakeup the radio if it is in Sleep mode and check that Busy is low
 */
void SX126xCheckDeviceReady(void);

/*!
 * \brief Saves the payload to be send in the radio buffer
 *
 * \param [in]  payload       A pointer to the payload
 * \param [in]  size          The size of the payload
 */
void SX126xSetPayload(uint8_t* payload, uint8_t size);

/*!
 * \brief Reads the payload received. If the received payload is longer
 * than maxSize, then the method returns 1 and do not set size and payload.
 *
 * \param [out] payload       A pointer to a buffer into which the payload will be copied
 * \param [out] size          A pointer to the size of the payload received
 * \param [in]  maxSize       The maximal size allowed to copy into the buffer
 */
uint8_t SX126xGetPayload(uint8_t* payload, uint8_t* size, uint8_t maxSize);

/*!
 * \brief Sends a payload
 *
 * \param [in]  payload       A pointer to the payload to send
 * \param [in]  size          The size of the payload to send
 * \param [in]  timeout       The timeout for Tx operation
 */
void SX126xSendPayload(uint8_t* payload, uint8_t size, uint32_t timeout);

/*!
 * \brief Sets the Sync Word given by index used in GFSK
 *
 * \param [in]  syncWord      SyncWord bytes ( 8 bytes )
 *
 * \retval      status        [0: OK, 1: NOK]
 */
uint8_t SX126xSetFSKSyncWord(uint8_t* syncWord);

/*!
 * \brief Sets the Initial value for the LFSR used for the CRC calculation
 *
 * \param [in]  seed          Initial LFSR value ( 2 bytes )
 *
 */
void SX126xSetCrcSeed(uint16_t seed);

/*!
 * \brief Sets the seed used for the CRC calculation
 *
 * \param [in]  seed          The seed value
 *
 */
void SX126xSetCrcPolynomial(uint16_t seed);

/*!
 * \brief Sets the Initial value of the LFSR used for the whitening in GFSK protocols
 *
 * \param [in]  seed          Initial LFSR value
 */
void SX126xSetWhiteningSeed(uint16_t seed);

/*!
 * \brief Gets a 32 bits random value generated by the radio
 *
 * \remark The radio must be in reception mode before executing this function
 *
 * \retval randomValue    32 bits random value
 */
uint32_t SX126xGetRandom(void);

/*!
 * \brief Sets the radio in sleep mode
 *
 * \param [in]  sleepConfig   The sleep configuration describing data
 *                            retention and RTC wake-up
 */
void SX126xSetSleep(SleepParams_t sleepConfig);

/*!
 * \brief Sets the radio in configuration mode
 *
 * \param [in]  mode          The standby mode to put the radio into
 */
void SX126xSetStandby(RadioStandbyModes_t mode);

/*!
 * \brief Sets the radio in FS mode
 */
void SX126xSetFs(void);

/*!
 * \brief Sets the radio in transmission mode
 *
 * \param [in]  timeout       Structure describing the transmission timeout value
 */
void SX126xSetTx(uint32_t timeout);

/*!
 * \brief Sets the radio in reception Boosted mode
 *
 * \param [in]  timeout       Structure describing the transmission timeout value
 */
void SX126xSetRxBoosted(uint32_t timeout);

/*!
 * \brief Sets the radio in reception mode
 *
 * \param [in]  timeout       Structure describing the reception timeout value
 */
void SX126xSetRx(uint32_t timeout);

/*!
 * \brief Sets the Rx duty cycle management parameters
 *
 * \param [in]  rxTime        Structure describing reception timeout value
 * \param [in]  sleepTime     Structure describing sleep timeout value
 */
void SX126xSetRxDutyCycle(uint32_t rxTime, uint32_t sleepTime);

/*!
 * \brief Sets the radio in CAD mode
 */
void SX126xSetCad(void);

/*!
 * \brief Sets the radio in continuous wave transmission mode
 */
void SX126xSetTxContinuousWave(void);

/*!
 * \brief Sets the radio in continuous preamble transmission mode
 */
void SX126xSetTxInfinitePreamble(void);

/*!
 * \brief Decide which interrupt will stop the internal radio rx timer.
 *
 * \param [in]  enable          [0: Timer stop after header/syncword detection
 *                               1: Timer stop after preamble detection]
 */
void SX126xSetStopRxTimerOnPreambleDetect(uint8_t enable);

/*!
 * \brief Set the number of symbol the radio will wait to validate a reception
 *
 * \param [in]  SymbNum          number of LoRa symbols
 */
void SX126xSetLoRaSymbNumTimeout(uint8_t SymbNum);

/*!
 * \brief Sets the power regulators operating mode
 *
 * \param [in]  mode          [0: LDO, 1:DC_DC]
 */
void SX126xSetRegulatorMode(RadioRegulatorMode_t mode);

/*!
 * \brief Calibrates the given radio block
 *
 * \param [in]  calibParam    The description of blocks to be calibrated
 */
void SX126xCalibrate(CalibrationParams_t calibParam);

/*!
 * \brief Calibrates the Image rejection depending of the frequency
 *
 * \param [in]  freq    The operating frequency
 */
void SX126xCalibrateImage(uint32_t freq);

/*!
 * \brief Sets the transmission parameters
 *
 * \param [in]  paDutyCycle     Duty Cycle for the PA
 * \param [in]  HpMax           0 for sx1261, 7 for sx1262
 * \param [in]  deviceSel       1 for sx1261, 0 for sx1262
 * \param [in]  paLUT           0 for 14dBm LUT, 1 for 22dBm LUT
 */
void SX126xSetPaConfig(uint8_t paDutyCycle, uint8_t HpMax, uint8_t deviceSel, uint8_t paLUT);

/*!
 * \brief Defines into which mode the chip goes after a TX / RX done
 *
 * \param [in]  fallbackMode    The mode in which the radio goes
 */
void SX126xSetRxTxFallbackMode(uint8_t fallbackMode);

/*!
 * \brief   Sets the IRQ mask and DIO masks
 *
 * \param [in]  irqMask       General IRQ mask
 * \param [in]  dio1Mask      DIO1 mask
 * \param [in]  dio2Mask      DIO2 mask
 * \param [in]  dio3Mask      DIO3 mask
 */
void SX126xSetDioIrqParams(uint16_t irqMask, uint16_t dio1Mask, uint16_t dio2Mask, uint16_t dio3Mask);

/*!
 * \brief Returns the current IRQ status
 *
 * \retval      irqStatus     IRQ status
 */
uint16_t SX126xGetIrqStatus(void);

/*
 * \brief Indicates if DIO2 is used to control an RF Switch
 *
 * \param [in] enable     true of false
 */
void SX126xSetDio2AsRfSwitchCtrl(uint8_t enable);

/*
 * \brief Indicates if the Radio main clock is supplied from a tcxo
 *
 * \param [in] tcxoVoltage     voltage used to control the TCXO
 * \param [in] timeout         time given to the TCXO to go to 32MHz
 */
void SX126xSetDio3AsTcxoCtrl(RadioTcxoCtrlVoltage_t tcxoVoltage, uint32_t timeout);

/*!
 * \brief Sets the RF frequency
 *
 * \param [in]  frequency     RF frequency [Hz]
 */
void SX126xSetRfFrequency(uint32_t frequency);

/*!
 * \brief Sets the radio for the given protocol
 *
 * \param [in]  packetType    [PACKET_TYPE_GFSK, PACKET_TYPE_LORA]
 *
 * \remark This method has to be called before SetRfFrequency,
 *         SetModulationParams and SetPacketParams
 */
void SX126xSetPacketType(RadioPacketTypes_t packetType);

/*!
 * \brief Gets the current radio protocol
 *
 * \retval      packetType    [PACKET_TYPE_GFSK, PACKET_TYPE_LORA]
 */
RadioPacketTypes_t SX126xGetPacketType(void);

/*!
 * \brief Sets the transmission parameters
 *
 * \param [in]  power         RF output power [-18..13] dBm
 * \param [in]  rampTime      Transmission ramp up time
 */
void SX126xSetTxParams(int8_t power, RadioRampTimes_t rampTime);

/*!
 * \brief Set the modulation parameters
 *
 * \param [in]  modParams     A structure describing the modulation parameters
 */
void SX126xSetModulationParams(ModulationParams_t* modParams);

/*!
 * \brief Sets the packet parameters
 *
 * \param [in]  packetParams  A structure describing the packet parameters
 */
void SX126xSetPacketParams(PacketParams_t* packetParams);

/*!
 * \brief Sets the Channel Activity Detection (CAD) parameters
 *
 * \param [in]  cadSymbolNum   The number of symbol to use for CAD operations
 *                             [LORA_CAD_01_SYMBOL, LORA_CAD_02_SYMBOL,
 *                              LORA_CAD_04_SYMBOL, LORA_CAD_08_SYMBOL,
 *                              LORA_CAD_16_SYMBOL]
 * \param [in]  cadDetPeak     Limite for detection of SNR peak used in the CAD
 * \param [in]  cadDetMin      Set the minimum symbol recognition for CAD
 * \param [in]  cadExitMode    Operation to be done at the end of CAD action
 *                             [LORA_CAD_ONLY, LORA_CAD_RX, LORA_CAD_LBT]
 * \param [in]  cadTimeout     Defines the timeout value to abort the CAD activity
 */
void SX126xSetCadParams(RadioLoRaCadSymbols_t cadSymbolNum, uint8_t cadDetPeak, uint8_t cadDetMin, RadioCadExitModes_t cadExitMode, uint32_t cadTimeout);

/*!
 * \brief Sets the data buffer base address for transmission and reception
 *
 * \param [in]  txBaseAddress Transmission base address
 * \param [in]  rxBaseAddress Reception base address
 */
void SX126xSetBufferBaseAddresses(uint8_t txBaseAddress, uint8_t rxBaseAddress);

/*!
 * \brief Gets the current radio status
 *
 * \retval      status        Radio status
 */
RadioStatus_t SX126xGetStatus(void);

/*!
 * \brief Returns the instantaneous RSSI value for the last packet received
 *
 * \retval      rssiInst      Instantaneous RSSI
 */
int8_t SX126xGetRssiInst(void);

/*!
 * \brief Gets the last received packet buffer status
 *
 * \param [out] payloadLength Last received packet payload length
 * \param [out] rxStartBuffer Last received packet buffer address pointer
 */
void SX126xGetRxBufferStatus(uint8_t* payloadLength, uint8_t* rxStartBuffer);

/*!
 * \brief Gets the last received packet payload length
 *
 * \param [out] pktStatus     A structure of packet status
 */
void SX126xGetPacketStatus(PacketStatus_t* pktStatus);

/*!
 * \brief Returns the possible system erros
 *
 * \retval sysErrors Value representing the possible sys failures
 */
RadioError_t SX126xGetDeviceErrors(void);

/*!
 * \brief Clears the IRQs
 *
 * \param [in]  irq           IRQ(s) to be cleared
 */
void SX126xClearIrqStatus(uint16_t irq);

/*!
 * \brief Set the driver in polling mode.
 *
 * In polling mode the application is responsible to call ProcessIrqs( ) to
 * execute callbacks functions.
 * The default mode is Interrupt Mode.
 * @code
 * // Initializations and callbacks declaration/definition
 * radio = SX126x( mosi, miso, sclk, nss, busy, int1, int2, int3, rst, &callbacks );
 * radio.Init( );
 * radio.SetPollingMode( );
 *
 * while( true )
 * {
 *                            //     IRQ processing is automatically done
 *     radio.ProcessIrqs( );  // <-- here, as well as callback functions
 *                            //     calls
 *     // Do some applicative work
 * }
 * @endcode
 *
 * \see SX126x::SetInterruptMode
 */
void SX126xSetPollingMode(void);

/*!
 * \brief Set the driver in interrupt mode.
 *
 * In interrupt mode, the driver communicate with the radio during the
 * interruption by direct calls to ProcessIrqs( ). The main advantage is
 * the possibility to have low power application architecture.
 * This is the default mode.
 * @code
 * // Initializations and callbacks declaration/definition
 * radio = SX126x( mosi, miso, sclk, nss, busy, int1, int2, int3, rst, &callbacks );
 * radio.Init( );
 * radio.SetInterruptMode( );   // Optionnal. Driver default behavior
 *
 * while( true )
 * {
 *     // Do some applicative work
 * }
 * @endcode
 *
 * \see SX126x::SetPollingMode
 */
void SX126xSetInterruptMode(void);

/*!
 * \brief Resets the radio
 */
//void Reset(void);

/*!
 * \brief Wake-ups the radio from Sleep mode
 */
//void Wakeup(void);

/*!
 * \brief Writes the given command to the radio
 *
 * \param [in]  opcode        Command opcode
 * \param [in]  buffer        Command parameters byte array
 * \param [in]  size          Command parameters byte array size
 */
//void WriteCommand(RadioCommands_t opcode, uint8_t* buffer, uint16_t size);

/*!
 * \brief Reads the given command from the radio
 *
 * \param [in]  opcode        Command opcode
 * \param [in]  buffer        Command parameters byte array
 * \param [in]  size          Command parameters byte array size
 */
//void ReadCommand(RadioCommands_t opcode, uint8_t* buffer, uint16_t size);

/*!
 * \brief Writes multiple radio registers starting at address
 *
 * \param [in]  address       First Radio register address
 * \param [in]  buffer        Buffer containing the new register's values
 * \param [in]  size          Number of registers to be written
 */
//void WriteRegister(uint16_t address, uint8_t* buffer, uint16_t size);

/*!
 * \brief Writes the radio register at the specified address
 *
 * \param [in]  address       Register address
 * \param [in]  value         New register value
 */
//void WriteReg(uint16_t address, uint8_t value);

/*!
 * \brief Reads multiple radio registers starting at address
 *
 * \param [in]  address       First Radio register address
 * \param [out] buffer        Buffer where to copy the registers data
 * \param [in]  size          Number of registers to be read
 */
//void ReadRegister(uint16_t address, uint8_t* buffer, uint16_t size);

/*!
 * \brief Reads the radio register at the specified address
 *
 * \param [in]  address       Register address
 *
 * \retval      data          Register value
 */
//uint8_t ReadReg(uint16_t address);

/*!
 * \brief Writes Radio Data Buffer with buffer of size starting at offset.
 *
 * \param [in]  offset        Offset where to start writing
 * \param [in]  buffer        Buffer pointer
 * \param [in]  size          Buffer size
 */
//void WriteBuffer(uint8_t offset, uint8_t* buffer, uint8_t size);

/*!
 * \brief Reads Radio Data Buffer at offset to buffer of size
 *
 * \param [in]  offset        Offset where to start reading
 * \param [out] buffer        Buffer pointer
 * \param [in]  size          Buffer size
 */
//void ReadBuffer(uint8_t offset, uint8_t* buffer, uint8_t size);

/*!
 * \brief Gets the current status of the radio DIOs
 *
 * \retval      status        [Bit #3: DIO3, Bit #2: DIO2,
 *                             Bit #1: DIO1, Bit #0: BUSY]
 */
//uint8_t GetDioStatus(void);

/*!
 * \brief Returns the device type
 *
 * \retval      0: SX1261, 1: SX1262, 2: SX1268
 */
//uint8_t GetDeviceType(void);

/*!
 * \brief Returns the matching frequency
 *
 * \retval      1: 868 MHz
 *              0: 915 MHz
 */
//uint8_t GetFreqSelect(void);

/*!
 * \brief RF Switch power on
 */
//void AntSwOn(void);

/*!
 * \brief RF Switch power off
 */
//void AntSwOff(void);

/*!
 * \brief Process the analysis of radio IRQs and calls callback functions
 *        depending on radio state
 */
void SX126xProcessIrqs(void);


#endif // __SX126x_H__

